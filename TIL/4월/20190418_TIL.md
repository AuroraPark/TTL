
오늘 오전에 jsp 마무리

## 오늘의 SQL


### 1. DICTIONARY

```
DESC dictionary
```

```
SELECT *
FROM dictionary;

SELECT *

FROM dictionary

WHERE table_name LIKE 'USER%'; -- 대문자
```
			

### 2. DDL

delete from s_emp;-- DDL 이라서 rollback 가능
truncate table s_emp; -- DDL 이라서 rollback 불가

== 테스트시 매우 주의 !!!!!!!!!!!!!
가상 테이블 만들어서 테스트하기


### 3. INDEX
    
####  Q. S_EMP 테이블의 이름 컬럼에 인덱스를 추가하시오.
```
CREATE INDEX IND_S_EMP

ON S_EMP(name);
```



### 4.  VIEW
```
DESC user_views

SELECT * FROM USER_VIEWS;
```

```
CREATE VIEW VW_S_EMP as select id, name, title from s_emp;

SELECT * FROM VW_S_EMP;
```

### 5. DECODE
```
> 급여 등급 나타내기, 급여로 등급 나누기 (비교하여 해당하는 값을 돌려줌)
SELECT name,salary, 

DECODE(

TRUNC(SALARY/1000), 0, 'E',1, 'D', 2, 'C', 3, 'B', 'A') 급여등급	 

FROM S_EMP;
```

### 6. CASE 문
```
SELECT id, name,
    
    CASE salary
    
        WHEN 1000 THEN 'Low'
        WHEN 5000 THEN 'High'
        ELSE 'Medium'
    
    END
    
FROM s_emp
;
```
```
SELECT id, name,
    
    CASE
    
        WHEN salary < 1000 THEN 'Very Low'
        WHEN salary >= 1000 AND salary <= 5000 THEN 'Low'
        WHEN salary > 5000 THEN 'High'
        ELSE 'Medium'
    
    END
    
FROM s_emp
;
```


#### > PIVOT 함수가 지원되지 않는 경우 DECODE함수로 처리
```
SELECT dept_id,

    COUNT(DECODE(title, '사원',0)) "사원",
    COUNT(DECODE(title, '과장',0)) "과장",
    COUNT(DECODE(title, '부장',0)) "부장",
    COUNT(DECODE(title, '이사',0)) "이사",
    COUNT(DECODE(title, '사장',0)) "사장"

FROM s_emp

GROUP BY dept_id

ORDER BY dept_id;
```

### 7. CORRELATED SubQUERY

- 서브쿼리에서 메인쿼리의 

```
> Q. 자신의 급여가 자신이 속한 부소의 평균 급여보다 적은 인원에 대해
>   이름, 급여, 부서번호를 출력하시오

SELECT name, salary, dept_id

FROM s_emp outer

WHERE salary < (    SELECT AVG(salary)

                    FROM s_emp

                    WHERE dept_id = outer.dept_id);
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NTIwMDc1NDQsLTE3Nzk4ODg0NzgsLT
Q1NDc4MjI3NywtMTE4ODkzNTg5NiwtMTU0ODA4OTgyNCwxMzQ4
ODc4MDAxLC0yNDI3MjY4MzUsMTYxNzMwNDg1MywtMzM4NzY3OT
U0XX0=
-->