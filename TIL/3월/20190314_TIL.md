# today!!!!!요약!!!!!
- **yeild** : Busy wait 피하기위해
- **join**: 인터럽트 후 작업할 시간을 줘야해

데이터가 보호 X

> ->동기화 (메서드전체/ 어떤블럭) : 데이타 보호를 위해 묶어두는것

동기화 해야 음수값 X

그런데 일이 진행 X

> -> wait & notify

그런데 쓰레드 통지 잘못감

> -> condition 으로 구분

> volatile : 메모리에서 직접 읽어옴

 : 정확도는 높지만 효율은 떨어짐

# today!!!!진도!!!!

### 병행과 병렬
- **병행** : 같이 진행
- **병렬** : 큰 하나의 작업을 쪼개서 돌림
	- 빅데이터 
		1. 가공
		2. 정제
		3. 분류/분석

### 쓰레드의 동기화 - wait, notify, notifyAll

만약 테이블(공유자원)을 두고 요리사(쓰레드) 손님(쓰레드) 가 있을 때
```
- 테이블은 열쇠가 있는 한 사람 (쓰레드)만 접근 가능
(기다렸다 일이 끝나면 접근 허용 - 열쇠를 받아서 들어옴)
- 접근하려면 '열쇠' 가 필요하고 객체당 하나뿐
- 모든 객체는 '자물쇠'를 가지고 있음
```			

> -> 해결 : synchronized  동기화

-  ArrayList 동기화 X
- Vector 동기화 O


### 문제 1. 비효율

손님이 테이블을 사용중인데 **요리가 없는 경우** 

**손님이 테이블을 계속 써서** 진행이 안되는 문제점

(요리사 쓰레드가 테이블을 쓸 수 없어서 요리를 놓을 수 없다.)



> 해결 : wait & notify 사용

- 요리가 없을경우
- 손님쓰레드가 자물쇠를 놓음 - waitting pool로 감(대기)
- 요리사가 요리 만들어지면 notify 해줌
- 손님이 음식을 먹음

### 문제 2. 재진입 비효율

이때, notify는 랜덤으로 1명
이기 때문에 **기아 현상**이 일어날 수 있음

> 해결 : notifyAll 사용 

- 일단 다 깨운 후 스케쥴러가 할애
- 감소하긴 하지만 기아현상 발생



### 문제 3. 쓰레드 구별 X

- 요리사와 손님 구별이 안되서 여전히 기아현상


> 해결 : lock & condition

- 쓰레드별 wait notify를 준다

* StampedLock :낙관적인 lock - 일단 저지르고 락 실행
	* 1. 작업수행
	* 2. 락획득
예를 들어
	ReadLock이면 그냥 읽기
	WriteLock 이면 기다렸다 락얻어서 읽기

-> 서버와 DB와의 동기화 필요
여러명 작업시 자원공유 동기화
효율이떨어져서 wait&notify
효율이 떨어져서 wait.signal - condition

### fork-join 프레임워크
fork : 하나의 작업을 작은 단위로 나눠서 여러 쓰레드가 동시에 처리(병렬처리)
join: 작업한 결과물들을 다시 합침

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwOTYwMjU4NjIsLTU2ODE3MDM4MiwtOT
k3OTE5ODk0LC0xMDEwMzU4NjY2LDE4Nzc0MTQzXX0=
-->